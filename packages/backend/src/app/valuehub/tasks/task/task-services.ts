/* eslint-disable @typescript-eslint/explicit-function-return-type */
import { ChatCompletionRequestMessageRoleEnum, Configuration, OpenAIApi } from 'openai'
import { databaseConnection } from '../../../database/database-connection'
import { PROMPT_MESSAGES, REGENERATE_PROMPT_MESSAGES } from '../../constants/prompts'
import { goalService } from '../../goals/goal/goal.service'
import { TaskEntity } from './task.entity'

const taskRepo = databaseConnection.getRepository(TaskEntity)


export type itaskdata =  {
    id: string
    goalId: number
    title: string
    description: string
    priority: string
    complexity: string
    colourTag: string
    dueDate: string
    status: string
    type: string
}

const configuration =  new Configuration({ apiKey: "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" })
const openai =  new OpenAIApi(configuration)

const autoRegeneratedTaskPrompt = (tasksPrompt: string, goal: { title: string, description: string, id: string }) => `
Already Created Task are: <tasks>${tasksPrompt}</tasks>.

Title of Goal: ${goal.title}. Description of Goal: ${goal.description}. Goal Id is ${goal.id}`



const onAskingQuestion = (history: { content: string }[]) => `
    You are a Project manager, assigned to ask a follow up question on the following information if something else is required or unclear.
    User will give answer to these question, please create a follow up question if something from these question is unclear.
    Question 1: ${ history[0].content } Answer: ${ history[1].content } //n 
    Question 2: ${ history[2].content } Answer: ${ history[3].content } //n
    Question 3: ${ history[4].content } Answer: ${ history[5].content } //n
    `
export const taskService = {
    


    async create(taskdata: itaskdata) {
        const { 
            goalId,
            title,
            description,
            priority,
            complexity,
            colourTag,
            dueDate,
            status,
            type,
        } = taskdata
        const task = {
            goalId,
            title,
            description,
            type,
            priority,
            complexity,
            colourTag,
            dueDate,
            status,
        }
        return taskRepo.save(task)
    },
    
    async update(id: number, taskdata: itaskdata) {
        const { 
            title,
            description,
            priority,
            complexity,
            status,
            colourTag,
            dueDate,
            type,
        } = taskdata
        const task = {
            title,
            description,
            priority,
            complexity,
            colourTag,
            status,
            type,
            dueDate,
        }
        
        return taskRepo.update(id, task)
    },

    async delete(id: number) {
        return taskRepo.delete(id)
    },

    async fetchAllTask(id: number) {
        return taskRepo.find({ where: { goalId: id } })
    },


    async autoGeneratedTaskList(goalId: string) {
        const goal = await goalService.fetchGoalById(goalId)
        const completion = await openai.createChatCompletion({  model: 'gpt-3.5-turbo', messages: [ ...PROMPT_MESSAGES, { role: ChatCompletionRequestMessageRoleEnum.User, content: `Title of Goal: ${goal?.title}. Description of Goal: ${goal?.description}. Goal Id is ${goalId}` }] })
        const tasks = JSON.parse(completion.data.choices[0]?.message?.content ?? '')
        
        if (tasks?.tasks?.length) {
            for (const task of tasks.tasks) {
                await taskService.create(task)
            }
        }
        else if (tasks?.length) {
            for (const task of tasks) {
                await taskService.create(task)
            }
        }
        else {
            return { error: true, data: null, message: 'Something went wrong during parsing, data is not formated correctly' }
        }
        
        return { error: false, data: [], message: 'Successfully created and added Taks.' }
        
    },


    async onboardingTask(history: any) {

        
        const completion = await openai.createChatCompletion({  model: 'gpt-3.5-turbo', messages: [ { role: 'assistant', content: onAskingQuestion(history.history) }, { role: ChatCompletionRequestMessageRoleEnum.User, content: 'Create a followup question based on previous questions and answer' }] })
        const data = completion.data.choices[0]?.message?.content
        
        return { error: false, data: data }
        
    },

    async autoRegeneratedTaskList(goalId: string) {
        const goal = await goalService.fetchGoalById(goalId)

        const previousTasks = await taskService.fetchAllTask(goal?.id ? parseInt(goal.id) : 1)

        let tasksPrompt = ''

        for (const task of previousTasks) {
            tasksPrompt += `Title: ${task.title} 
            Description: ${task.description}
            `
        }

        const completion = await openai.createChatCompletion({  model: 'gpt-3.5-turbo', max_tokens: 2000, messages: [ ...REGENERATE_PROMPT_MESSAGES, { role: ChatCompletionRequestMessageRoleEnum.User, content: autoRegeneratedTaskPrompt(tasksPrompt, { title: goal?.title ?? '', description: goal?.description ?? '', id: goalId }) }] })
        const tasks = JSON.parse(completion.data.choices[0]?.message?.content ?? '')

        if (tasks?.tasks?.length) {
            for (const task of tasks.tasks) {
                await taskService.create(task)
            }
        }
        else if (tasks?.length) {
            for (const task of tasks) {
                await taskService.create(task)
            }
        }
        else {
            return { error: true, data: null, message: 'Something went wrong during parsing, data is not formated correctly' }
        }
        
        return { error: false, data: tasks, message: 'Successfully created and added Taks.' }
    },
    
}


