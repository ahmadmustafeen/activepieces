/* eslint-disable @typescript-eslint/quotes */
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/explicit-function-return-type */
import { ChatCompletionRequestMessageRoleEnum, Configuration, OpenAIApi } from 'openai'
import { databaseConnection } from '../../../database/database-connection'
import { PROMPT_MESSAGES, REGENERATE_PROMPT_MESSAGES } from '../../constants/prompts'
import { goalService } from '../../goals/goal/goal.service'
import { TaskEntity } from './task.entity'
import { categoryService } from '../../category/category.service'

const taskRepo = databaseConnection.getRepository(TaskEntity)


export type itaskdata =  {
    id: string
    goalId: number
    title: string
    description: string
    priority: string
    complexity: string
    colourTag: string
    dueDate: string
    status: string
    type: string
}

const configuration =  new Configuration({ apiKey: process.env.OPENAI_API_KEY })
const openai =  new OpenAIApi(configuration)

const autoRegeneratedTaskPrompt = (tasksPrompt: string, goal: { title: string, description: string, id: string }) => `
Already Created Task are: <tasks>${tasksPrompt}</tasks>.

Title of Goal: ${goal.title}. Description of Goal: ${goal.description}. Goal Id is ${goal.id}`



const onAskingQuestion = (history: { content: string }[]) => `
    You are a Project manager, assigned to ask a follow up question on the following information if something else is required or unclear.
    User will give answer to these question, please create a follow up question if something from these question is unclear.
    Question 1: ${ history[0].content } Answer: ${ history[1].content } //n 
    Question 2: ${ history[2].content } Answer: ${ history[3].content } //n
    Question 3: ${ history[4].content } Answer: ${ history[5].content } //n
    `



const CreateGoalPrompt = (history: { content: string }[]) => `
Acting as a Project manager, you will be given the following set of questions and their response, by using this information, you will generate 200 words goal description and title.
We also need categories such as Artifcial Intelligence, Mobile Development etc etc.
The goal would be what the user wants to achieve and you will be giving the information in a proper format:

Format of response will be in json format: with key title: sting, description as string[] and category as string[]


These are the information
Question 1: ${ history[0].content } Answer: ${ history[1].content } //n 
Question 2: ${ history[2].content } Answer: ${ history[3].content } //n
Question 3: ${ history[4].content } Answer: ${ history[5].content } //n
`

export const taskService = {
    


    async create(taskdata: itaskdata) {
        const { 
            goalId,
            title,
            description,
            priority,
            complexity,
            colourTag,
            dueDate,
            status,
            type,
        } = taskdata
        const task = {
            goalId,
            title,
            description,
            type,
            priority,
            complexity,
            colourTag,
            dueDate,
            status,
        }
        return taskRepo.save(task)
    },
    
    async update(id: number, taskdata: itaskdata) {
        const { 
            title,
            description,
            priority,
            complexity,
            status,
            colourTag,
            dueDate,
            type,
        } = taskdata
        const task = {
            title,
            description,
            priority,
            complexity,
            colourTag,
            status,
            type,
            dueDate,
        }
        
        return taskRepo.update(id, task)
    },

    async delete(id: number) {
        return taskRepo.delete(id)
    },

    async fetchAllTask(id: number) {
        return taskRepo.find({ where: { goalId: id } })
    },


    async autoGeneratedTaskList(goalId: string) {
        const goal = await goalService.fetchGoalById(goalId)
        if (!goal) return { error: true, data: null, message: 'Goal Id not found' }
        
        const parsedDescription = JSON.parse(goal.description).join(" ")
        const completion = await openai.createChatCompletion({  model: 'gpt-3.5-turbo', messages: [ ...PROMPT_MESSAGES, { role: ChatCompletionRequestMessageRoleEnum.User, content: `Title of Goal: ${goal?.title}. Description of Goal: ${parsedDescription}. Goal Id is ${goalId}` }] })
        const tasks = JSON.parse(completion.data.choices[0]?.message?.content ?? '')
        
        if (tasks?.tasks?.length) {
            for (const task of tasks.tasks) {
                await taskService.create(task)
            }
        }
        else if (tasks?.length) {
            for (const task of tasks) {
                await taskService.create(task)
            }
        }
        else {
            return { error: true, data: null, message: 'Something went wrong during parsing, data is not formated correctly' }
        }
        
        return { error: false, data: [], message: 'Successfully created and added Taks.' }
        
    },

    async onboardingTask(history: any) {
        try {
            const completion = await openai.createChatCompletion({  model: 'gpt-3.5-turbo', messages: [ { role: 'assistant', content: onAskingQuestion(history.history) }, { role: ChatCompletionRequestMessageRoleEnum.User, content: 'Create a followup question based on previous questions and answer' }] })
            const data = completion.data.choices[0]?.message?.content
            return { error: false, data, message: '' }
        }
        catch (error: any) {
            console.log('error==>', error)
            return { error: false, data: null, message: error.message }
        }
    },

    async onAIGeneratedGoal(history: any) {
        try {
            const completion = await openai.createChatCompletion({  model: 'gpt-3.5-turbo', messages: [ { role: 'assistant', content: CreateGoalPrompt(history.history) }, { role: ChatCompletionRequestMessageRoleEnum.User, content: 'Create the goal' }] })
            const data = completion.data.choices[0]?.message?.content
            const parsedData = JSON.parse(data ?? '')
            const { title = '', category: categories = [], description = [] } = parsedData

            const parsedCategory: string[] = []

            for (const category of categories) {
                const Category =  await categoryService.fetchCategoryByTitle(category.toLowerCase())
                if (Category) parsedCategory.push(Category.id)

                else {
                    const createdCategory = await categoryService.create({ title: category.toLowerCase() })
                    if (createdCategory?.id) parsedCategory.push(createdCategory.id)
                }
            }

            const goalData = await goalService.create({ title, description: JSON.stringify(description), category: JSON.stringify(parsedCategory), createdBy: 'ahmad' })
            return { error: false, data: goalData, message: '' }
        }
        catch (error: any) {
            return { error: false, data: null, message: error.message }
        }
    },

    async autoRegeneratedTaskList(goalId: string) {
        const goal = await goalService.fetchGoalById(goalId)
        if (!goal) return { error: true, data: null, message: 'Goal Id not found' }
        
        const previousTasks = await taskService.fetchAllTask(parseInt(goal?.id))

        let tasksPrompt = ''

        for (const task of previousTasks) {
            tasksPrompt += `Title: ${task.title} 
            Description: ${task.description}
            `
        }

        const completion = await openai.createChatCompletion({  model: 'gpt-3.5-turbo', max_tokens: 2000, messages: [ ...REGENERATE_PROMPT_MESSAGES, { role: ChatCompletionRequestMessageRoleEnum.User, content: autoRegeneratedTaskPrompt(tasksPrompt, { title: goal?.title, description: goal.description  , id: goalId }) }] })
        const tasks = JSON.parse(completion.data.choices[0]?.message?.content ?? '')

        if (tasks?.tasks?.length) {
            for (const task of tasks.tasks) {
                await taskService.create(task)
            }
        }
        else if (tasks?.length) {
            for (const task of tasks) {
                await taskService.create(task)
            }
        }
        else {
            return { error: true, data: null, message: 'Something went wrong during parsing, data is not formated correctly' }
        }
        
        return { error: false, data: tasks, message: 'Successfully created and added Taks.' }
    },
    
}


