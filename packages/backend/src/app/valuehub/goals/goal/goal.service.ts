/* eslint-disable @typescript-eslint/explicit-function-return-type */
import { ChatCompletionRequestMessageRoleEnum, Configuration, OpenAIApi } from 'openai'
import { databaseConnection } from '../../../database/database-connection'
import { userService } from '../../../user/user-service'
import { categoryService } from '../../category/category.service'
import { GoalEntity } from './goal.entity'

const goalRepo = databaseConnection.getRepository(GoalEntity)


type igoaldata =  {
    createdBy: string
    title: string
    description: string[]
    category: string[]
}

const CreateManualGoalInitialPrompt = `
Act as a project manager, and based on the following requirement return the objective of goal and detailed description.

format for return will be a json

{
    "title": generated by AI,
    "catgory": [generated by AI],
    "description": generated by AI,
}

`

type icreateGoal = {
    createdBy: string
    description: string
    raw_description: string
}
const configuration =  new Configuration({ apiKey: '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' })
const openai =  new OpenAIApi(configuration)

export const goalService = {
    async create(goaldata: igoaldata) {
        const { createdBy, title, description = [], category: categories } = goaldata
      
        const parsedCategory: string[] = []

        for (const category of categories) {
            const Category =  await categoryService.fetchCategoryByTitle(category.toLowerCase())
            if (Category) parsedCategory.push(Category.id)

            else {
                const createdCategory = await categoryService.create({ title: category.toLowerCase() })
                if (createdCategory?.id) parsedCategory.push(createdCategory.id)
            }
        }

        const goal = {
            createdBy,
            title,
            category: JSON.stringify(parsedCategory),
            description: JSON.stringify(description),
        }

        
        return goalRepo.save(goal)
    },
    
    async update(id: number, goaldata: igoaldata) {
        const { createdBy, title, description, category: categories = [] } = goaldata

        const parsedCategory: string[] = []

        for (const category of categories) {
            const Category =  await categoryService.fetchCategoryByTitle(category.toLowerCase())
            if (Category) parsedCategory.push(Category.id)

            else {
                const createdCategory = await categoryService.create({ title: category.toLowerCase() })
                if (createdCategory?.id) parsedCategory.push(createdCategory.id)
            }
        }

        const goal = {
            createdBy,
            title,
            description: description?.length ?  JSON.stringify(description) : undefined,
            category: parsedCategory.length ? JSON.stringify(parsedCategory) : undefined,
        }

        return goalRepo.update(id, goal)
    },

    async delete(id: number) {
        return goalRepo.delete(id)
    },

    async fetchAllGoals() {
        const goals = await goalRepo.find()
        
        const updatedGoal = []

        for (const eachGoal of goals) {
            const user = await userService.getUser({ id: eachGoal.createdBy })
            
            const categoryArray = []
            for (const category of JSON.parse(eachGoal.category)) {
                const categoryData = await categoryService.fetchCategoryById(category)
                if (categoryData) categoryArray.push(categoryData)
            }
            updatedGoal.push({ ...eachGoal, userData: user, category: categoryArray, description: eachGoal.description, raw_description: eachGoal.raw_description })
        }

        
        return updatedGoal
        
    },

    async fetchGoalById(id: string) {
        const goal = await goalRepo.findOne({ where: { id } })
        if (!goal) return null
        const categoryArray = []
        for (const category of JSON.parse(goal.category)) {
            const categoryData = await categoryService.fetchCategoryById(category)
            if (categoryData) categoryArray.push(categoryData)
        }
        return { ...goal, category: categoryArray }
    },

    async createGoal(goaldata: icreateGoal) {
        const { description = '', raw_description = '', createdBy } = goaldata

        const completion = await openai.createChatCompletion({  model: 'gpt-3.5-turbo', messages: [ { role: 'assistant', content: CreateManualGoalInitialPrompt }, { role: ChatCompletionRequestMessageRoleEnum.User, content: `Create the goal based on the following XML: ${description}` }] })
            
        const data = completion.data.choices[0]?.message?.content ?? ''
    
    
        const { category: categories = [], title = '', description: parsedDescription } = JSON.parse(data)

        const parsedCategory = []

        for (const category of categories) {
            const Category =  await categoryService.fetchCategoryByTitle(category.toLowerCase())
            if (Category) parsedCategory.push(Category.id)

            else {
                const createdCategory = await categoryService.create({ title: category.toLowerCase() })
                if (createdCategory?.id) parsedCategory.push(createdCategory.id)
            }
        }

        const goal = {
            createdBy,
            title,
            category: JSON.stringify(parsedCategory),
            raw_description: JSON.stringify(raw_description),
            description: parsedDescription,
        }

        console.log(goal)
        
        
        return goalRepo.save(goal)
    },

    
}
